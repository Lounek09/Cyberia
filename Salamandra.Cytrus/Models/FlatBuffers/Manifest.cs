// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Salamandra.Cytrus.Models.FlatBuffers
{

    using global::System;
    using global::System.Collections.Generic;
    using global::Google.FlatBuffers;

    public struct Manifest : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_22_12_06(); }
        public static Manifest GetRootAsManifest(ByteBuffer _bb) { return GetRootAsManifest(_bb, new Manifest()); }
        public static Manifest GetRootAsManifest(ByteBuffer _bb, Manifest obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
        public Manifest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Salamandra.Cytrus.Models.FlatBuffers.Fragment? Fragments(int j) { int o = __p.__offset(4); return o != 0 ? (Salamandra.Cytrus.Models.FlatBuffers.Fragment?)(new Salamandra.Cytrus.Models.FlatBuffers.Fragment()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int FragmentsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

        public static Offset<Salamandra.Cytrus.Models.FlatBuffers.Manifest> CreateManifest(FlatBufferBuilder builder,
            VectorOffset fragmentsOffset = default(VectorOffset)) {
            builder.StartTable(1);
            Manifest.AddFragments(builder, fragmentsOffset);
            return Manifest.EndManifest(builder);
        }

        public static void StartManifest(FlatBufferBuilder builder) { builder.StartTable(1); }
        public static void AddFragments(FlatBufferBuilder builder, VectorOffset fragmentsOffset) { builder.AddOffset(0, fragmentsOffset.Value, 0); }
        public static VectorOffset CreateFragmentsVector(FlatBufferBuilder builder, Offset<Salamandra.Cytrus.Models.FlatBuffers.Fragment>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateFragmentsVectorBlock(FlatBufferBuilder builder, Offset<Salamandra.Cytrus.Models.FlatBuffers.Fragment>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateFragmentsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Salamandra.Cytrus.Models.FlatBuffers.Fragment>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateFragmentsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Salamandra.Cytrus.Models.FlatBuffers.Fragment>>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartFragmentsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static Offset<Salamandra.Cytrus.Models.FlatBuffers.Manifest> EndManifest(FlatBufferBuilder builder) {
            int o = builder.EndTable();
            return new Offset<Salamandra.Cytrus.Models.FlatBuffers.Manifest>(o);
        }
        public static void FinishManifestBuffer(FlatBufferBuilder builder, Offset<Salamandra.Cytrus.Models.FlatBuffers.Manifest> offset) { builder.Finish(offset.Value); }
        public static void FinishSizePrefixedManifestBuffer(FlatBufferBuilder builder, Offset<Salamandra.Cytrus.Models.FlatBuffers.Manifest> offset) { builder.FinishSizePrefixed(offset.Value); }

        private Dictionary<int, Fragment> GetFragments()
        {
            Dictionary<int, Fragment> fragments = new();

            for (int i = 0; i < FragmentsLength; i++)
                fragments.Add(i, Fragments(i).Value);

            return fragments;
        }

        /// <summary>
        /// Generate a file that lists all differences between two manifests
        /// </summary>
        /// <param name="old">The old manifest to diff to</param>
        /// <param name="outputPath">The path of the generated file</param>
        public void DiffFiles(Manifest old, out string outputPath)
        {
            outputPath = $"{Constant.OUTPUT_PATH}/file.diff";

            List<KeyValuePair<int, List<string>>> diff = new();

            Dictionary<int, Fragment> currentFragments = GetFragments();
            Dictionary<int, Fragment> oldFragments = old.GetFragments();

            Dictionary<string, int> oldFragmentKeys = new Dictionary<string, int>();
            foreach (KeyValuePair<int, Fragment> fragment in oldFragments)
                oldFragmentKeys[fragment.Value.Name] = fragment.Key;

            HashSet<int> processedKeys = new();
            foreach (KeyValuePair<int, Fragment> fragment in currentFragments)
            {
                List<string> fragmentDiff = new();

                if (oldFragmentKeys.TryGetValue(fragment.Value.Name, out int oldKey))
                {
                    fragmentDiff = fragment.Value.DiffFiles(oldFragments[oldKey]);
                    processedKeys.Add(oldKey);
                }
                else
                {
                    fragmentDiff.Add($"// {fragment.Value.Name.ToUpper()} \\\\");
                    for (int i = 0; i < fragment.Value.FilesLength; i++)
                        fragmentDiff.Add($"+ {fragment.Value.Files(i).Value.Name}");
                }

                if (fragmentDiff.Count > 1)
                    diff.Add(new(fragment.Key, fragmentDiff));
            }

            foreach (int key in oldFragments.Keys.Except(processedKeys))
            {
                Fragment fragment = oldFragments[key];

                List<string> fragmentDiff = new()
                {
                    $"// {fragment.Name.ToUpper()} \\\\"
                };

                for (int i = 0; i < fragment.FilesLength; i++)
                    fragmentDiff.Add($"- {fragment.Files(i).Value.Name}");

                if (fragmentDiff.Count > 1)
                    diff.Add(new(key, fragmentDiff));
            }

            List<string> output = new();
            if (diff.Count > 0)
            {
                foreach (KeyValuePair<int, List<string>> orderedFragmentDiff in diff.OrderBy(x => x.Key))
                {
                    output.AddRange(orderedFragmentDiff.Value);
                    output.Add("");
                }
            }
            else
                output.Add("Aucune différence");

            File.WriteAllLines(outputPath, output, System.Text.Encoding.UTF8);
        }
    }
}
